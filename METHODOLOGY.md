# Computational Methodology

## Overview

This document provides detailed technical information about how the 109-million-digit candidate Q₅₉(10^1886792 + 3) was computed.

## Mathematical Formula

The candidate is generated by the polynomial:

```
Q_n(q) = q^n - (q-1)^n
```

With parameters:
- **n** = 59 (prime exponent)
- **q** = 10^1886792 + 3

## Binomial Expansion

Using the binomial theorem, this expands to:

```
Q₅₉(q) = 59·q^58 - C(59,2)·q^57 + C(59,3)·q^56 - ... + (−1)^58
```

For large q, the leading term dominates:
```
Q₅₉(q) ≈ 59·q^58
```

## Expected Digit Count

The number of digits can be estimated:

```
digits ≈ (n-1) × log₁₀(q)
       = 58 × 1,886,792
       = 109,433,936
```

Actual count: **109,433,938** (difference of 2 digits, or 0.000002%)

## Computation Algorithm

### Step 1: Base Construction

```python
q = 10**1886792 + 3
```

Python's arbitrary-precision integer arithmetic handles this natively.

### Step 2: Power Computation

```python
q_power = q**59
q_minus_1_power = (q-1)**59
```

Python uses Karatsuba multiplication and optimized exponentiation.

### Step 3: Final Calculation

```python
result = q_power - q_minus_1_power
```

### Step 4: String Conversion

```python
sys.set_int_max_str_digits(0)  # Critical: removes default limit
result_str = str(result)
```

This is the most time-consuming step (~16 minutes).

### Step 5: Fingerprinting

```python
sha256_hash = hashlib.sha256(result_str.encode('utf-8')).hexdigest()
```

## Computational Complexity

### Theoretical Complexity

For a number N with d digits:
- **Multiplication**: O(d log d) using FFT
- **Exponentiation**: O(log n) multiplications
- **String conversion**: O(d²) in general, optimized in Python

### Actual Performance

On standard hardware (Intel Core, 32GB RAM):
- **Computation time**: ~975 seconds (~16 minutes)
- **Memory usage**: ~200MB peak (during string conversion)
- **String conversion**: Included in above time

## Hardware Requirements

### Minimum:
- **CPU**: Any modern x86-64 processor
- **RAM**: 4GB minimum, 8GB recommended
- **Storage**: Negligible (~1MB for results)
- **OS**: Linux, macOS, or Windows with Python 3.11+

### Tested Configuration:
- **CPU**: Intel Core i7 x86-64
- **RAM**: 32GB DDR4
- **OS**: Ubuntu 24.04 LTS
- **Python**: 3.11.0

## Software Requirements

### Python Version:
- **Minimum**: Python 3.11
- **Recommended**: Python 3.11 or higher

**Why 3.11?** Earlier versions may have issues with:
- Integer string conversion limits
- Performance optimizations

### Dependencies:
**None** - Uses only Python standard library:
- `sys` - System configuration
- `hashlib` - SHA-256 computation
- `time` - Performance measurement
- `os` - File operations

## Verification Protocol

### Primary Verification: SHA-256 Hash

The canonical fingerprint is:
```
A462032F37DC907EDEF64A575696EC0B11C052B42B469C76F6A6577B841864EF
```

To verify independently:
1. Compute Q₅₉(10^1886792 + 3)
2. Convert to decimal string
3. Calculate SHA-256(string)
4. Compare to above hash

### Secondary Verification: Structural Features

**Digit Count**: 109,433,938

**First 60 digits**:
```
590000000000000000000000000000000000000000000000000000000000
```

**Last 60 digits**:
```
000000000000000000000000000000014130386091162273752461387579
```

These provide quick sanity checks before full hash computation.

## Parameter Selection Rationale

### Why n=59?

**Prime exponent** - Avoids systematic divisibility patterns that affect composite exponents.

For composite n, Q_n(q) may have predictable factors.

### Why q = 10^1886792 + 3?

1. **Magnitude**: Chosen to produce >100M digits
   - Targets EFF prize threshold
   - 10^1886792 has 1,886,793 digits
   - (10^1886792)^58 has ~109M digits

2. **Base form**: Power of 10 plus small offset
   - Simplifies computation
   - Avoids certain small prime divisors

3. **Offset +3**: 
   - Selected through preliminary analysis
   - Avoids immediate divisibility by 2, 5

### Strategic Considerations

The parameters were chosen to:
- Exceed EFF 100M-digit threshold
- Remain computationally feasible to calculate
- Avoid obvious composite factors
- Enable efficient verification

## Reproducibility

### Exact Reproduction

To exactly reproduce the computation:

```bash
git clone https://github.com/Ruqing1963/q59-prime-candidate.git
cd q59-prime-candidate/scripts
python compute_q59.py
```

Expected output SHA-256: `A462032F37DC907E...`

### Independent Implementation

Alternatively, implement in any language with big integer support:

**Python**:
```python
import sys
sys.set_int_max_str_digits(0)
q = 10**1886792 + 3
result = q**59 - (q-1)**59
```

**Mathematica**:
```mathematica
q = 10^1886792 + 3;
result = q^59 - (q-1)^59;
```

**SageMath**:
```python
q = 10^1886792 + 3
result = q^59 - (q-1)^59
```

All should produce the same SHA-256 hash.

## Limitations and Caveats

### What This Computation Does:
✅ Computes the exact integer value  
✅ Establishes cryptographic fingerprint  
✅ Enables independent verification  
✅ Documents the methodology  

### What It Does NOT Do:
❌ Prove primality  
❌ Test for primality  
❌ Guarantee the number is prime  
❌ Qualify for EFF prize (requires proof)  

## Next Steps: Primality Verification

### Required for Probable Prime Status:

**Baillie-PSW Test** (industry standard):
1. **Miller-Rabin**: 20+ rounds with random bases
2. **Lucas Test**: Strong Lucas pseudoprime test

**Estimated resources**:
- Months of computation on supercomputers
- Distributed computing infrastructure
- Specialized primality testing software

### Required for Proven Prime Status:

**ECPP** (Elliptic Curve Primality Proving):
- Currently infeasible for 109M digits
- No number this large has been proven prime using ECPP
- Would require years on supercomputers

## References

1. Python Software Foundation. (2024). "Python Documentation: Built-in Types - Numeric Types"
   
2. Knuth, D. E. (1997). "The Art of Computer Programming, Vol. 2: Seminumerical Algorithms"

3. Bateman, P.T. & Horn, R.A. (1962). "A heuristic asymptotic formula concerning the distribution of prime numbers"

4. Electronic Frontier Foundation. "Cooperative Computing Awards"
   https://www.eff.org/awards/coop

## Contact

For technical questions about the methodology:
- **Email**: ruqing@hotmail.com
- **GitHub Issues**: https://github.com/Ruqing1963/q59-prime-candidate/issues

## License

This methodology document is licensed under CC-BY-4.0.
You are free to use, share, and adapt with attribution.

---

**Last Updated**: January 3, 2026  
**Version**: 1.0.0
